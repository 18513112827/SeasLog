{"name":"Seaslog","tagline":"Yet a log extension for PHP.","body":"# SeasLog\r\nYet a log extension for PHP.\r\n@author ciogao@gmail.com\r\n\r\n> ---\r\n- **[简介](#简介)**\r\n    - **[为什么使用SeasLog](#为什么使用seaslog)**\r\n    - **[目前提供了什么](#目前提供了什么)**\r\n    - **[目标是怎样的](#目标是怎样的)**\r\n- **[安装](#安装)**\r\n    - **[编译安装 SeasLog](#编译安装-seaslog)**\r\n    - **[seaslog.ini的配置](#seaslogini的配置)**\r\n- **[使用](#使用)**\r\n    - **[常量与函数](#常量与函数)**\r\n        - [常量列表](#常量列表)\r\n        - [函数列表](#函数列表)\r\n\t- **[SeasLog Logger的使用](#seaslog-logger的使用)**\r\n        - [获取与设置basePath](#获取与设置basepath)\r\n        - [设置logger与获取lastLogger](#设置logger与获取lastlogger)\r\n        - [快速写入log](#快速写入log)\r\n\t- **[SeasLog Analyzer的使用](#seaslog-analyzer的使用)**\r\n\t\t- [快速统计某类型log的count值](#快速统计某类型log的count值)\r\n\t\t- [获取某类型log列表](#获取某类型log列表)\r\n\t- **[使用SeasLog进行健康预警](#使用seaslog进行健康预警)**\r\n        - [预警的配置](#预警的配置)\r\n\t\t- [crontab配置](#crontab配置)\r\n        \r\n> ---\r\n\r\n## 简介\r\n### 为什么使用SeasLog\r\nlog日志，通常是系统或软件、应用的运行记录。通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。\r\n\r\nphp内置error_log、syslog函数功能强大且性能极好，但由于各种缺陷(error_log无错误级别、无固定格式，syslog不分模块、与系统日志混合)，灵活度降低了很多，不能满足应用需求。\r\n\r\n好消息是，有不少第三方的log类库弥补了上述缺陷，如log4php、plog、Analog等(当然也有很多应用在项目中自己开发的log类)。其中以[log4php](http://logging.apache.org/log4php/)最为著名，设计精良、格式完美、文档完善、功能强大。推荐。(log4php的性能有待测试)\r\n\r\n那么有没有一种log类库满足以下需求呢：\r\n* 分模块、分级别\r\n* 配置简单(最好是勿须配置)\r\n* 日志格式清晰易读\r\n* 应用简单、性能很棒\r\n\r\n`SeasLog` 正是应此需求而生。\r\n\r\n### 目前提供了什么\r\n* 在PHP项目中便捷、规范地记录log\r\n* 可配置的默认log目录与模块\r\n* 指定log目录与获取当前配置\r\n* 初步的分析预警框架\r\n\r\n\r\n### 目标是怎样的\r\n* 便捷、规范的log记录\r\n* 高效的海量log分析\r\n* 可配置、多途径的log预警\r\n\r\n## 安装\r\n\r\n### 编译安装 seaslog\r\n```sh\r\n$ /path/to/phpize\r\n$ ./configure --with-php-config=/path/to/php-config\r\n$ make && make install\r\n```\r\n\r\n### seaslog.ini的配置\r\n```conf\r\n; configuration for php SeasLog module\r\nextension = seaslog.so\r\nseaslog.default_basepath = /log/seaslog-test    ;默认log根目录\r\nseaslog.default_logger = default                ;默认logger目录\r\nseaslog.disting_type = 1                        ;是否以type分文件 1是 0否(默认)\r\n```\r\n> `seaslog.disting_type = 1` 开启以type分文件，即log文件区分info\\warn\\erro\r\n\r\n> `seaslog.disting_type = 0` 关闭以type分文件，即info\\warn\\erro统一记录于同一个log文件\r\n\r\n## 使用\r\n\r\n### 常量与函数\r\n#### 常量列表\r\n* SEASLOG_TYPE_INFO = 1\r\n* SEASLOG_TYPE_WARN = 2\r\n* SEASLOG_TYPE_ERRO = 3\r\n```php\r\nvar_dump(SEASLOG_TYPE_INFO,SEASLOG_TYPE_WARN,SEASLOG_TYPE_ERRO);\r\n/*\r\nint(1) info类型\r\nint(2) warn类型\r\nint(3) erro类型\r\n*/\r\n```\r\n#### 函数列表\r\n`SeasLog` 提供了这样一组函数，可以方便地获取与设置根目录、模块目录、快速写入与统计log。\r\n相信从下述伪代码的注释中，您可以快速获取函数信息，具体使用将紧接其后：\r\n```php\r\n<?php\r\n/**\r\n * @author ciogao@gmail.com\r\n * Date: 14-1-27 下午4:47\r\n */\r\n/**\r\n * 设置basePath\r\n * @param $basePath\r\n * @return bool\r\n */\r\nfunction seaslog_set_basepath($basePath)\r\n{\r\n    return TRUE;\r\n}\r\n\r\n/**\r\n * 获取basePath\r\n * @return string\r\n */\r\nfunction seaslog_get_basepath()\r\n{\r\n    return 'the base_path';\r\n}\r\n\r\n/**\r\n * 设置模块目录\r\n * @param $module\r\n * @return bool\r\n */\r\nfunction seaslog_set_logger($module)\r\n{\r\n    return TRUE;\r\n}\r\n\r\n/**\r\n * 获取最后一次设置的模块目录\r\n * @return string\r\n */\r\nfunction seaslog_get_lastlogger()\r\n{\r\n    return 'the lastLogger';\r\n}\r\n\r\n/**\r\n * 快速写入log\r\n * @param $msg\r\n * @param string $module\r\n * @param int $type\r\n * @return bool\r\n */\r\nfunction seaslog($msg, $type = SEASLOG_TYPE_INFO, $module = 'defaultPath')\r\n{\r\n    return TRUE;\r\n}\r\n\r\n/**\r\n * 统计所有类型（或单个类型）行数\r\n * @param string $type\r\n * @param string $log_path\r\n * @return array | long\r\n */\r\nfunction seaslog_analyzer_count($type = 'allType',$log_path = '*')\r\n{\r\n    return array();\r\n}\r\n\r\n/**\r\n * 以数组形式，快速取出某类型log的各行详情\r\n * @param $type\r\n * @param string $log_path\r\n * @return array\r\n */\r\nfunction seaslog_analyzer_detail($type = SEASLOG_TYPE_ERRO,$log_path = '*')\r\n{\r\n    return array();\r\n}\r\n\r\n```\r\n\r\n### SeasLog Logger的使用\r\n#### 获取与设置basePath\r\n```php\r\n$basePath_1 = seaslog_get_basepath();\r\n\r\nseaslog_set_basepath('/log/base_test');\r\n$basePath_2 = seaslog_get_basepath();\r\n\r\nvar_dump($basePath_1,$basePath_2);\r\n\r\n/*\r\nstring(19) \"/log/seaslog-ciogao\"\r\nstring(14) \"/log/base_test\"\r\n*/\r\n```\r\n> 直接使用 `seaslog_get_basepath()`，将获取php.ini(seaslog.ini)中设置的 `seaslog.default_basepath` 的值。\r\n\r\n> 使用 `seaslog_set_basepath()` 函数，将改变 `seaslog_get_basepath()` 的取值。\r\n\r\n#### 设置logger与获取lastLogger\r\n```php\r\n$lastLogger_1 = seaslog_get_lastlogger();\r\n\r\nseaslog_set_logger('testModule/app1');\r\n$lastLogger_2 = seaslog_get_lastlogger();\r\n\r\nvar_dump($lastLogger_1,$lastLogger_2);\r\n/*\r\nstring(7) \"default\"\r\nstring(15) \"testModule/app1\"\r\n*/\r\n```\r\n> 与basePath相类似的，\r\n\r\n> 直接使用 `seaslog_get_lastlogger()`，将获取php.ini(seaslog.ini)中设置的 `seaslog.default_logger` 的值。\r\n\r\n> 使用 `seaslog_set_logger()` 函数，将改变 `seaslog_get_lastlogger()` 的取值。\r\n\r\n#### 快速写入log\r\n上面已经设置过了basePath与logger，于是log记录的目录已经产生了，\r\n> log记录目录 = basePath / logger / {fileName}.log\r\nlog文件名，以 `年月日` 分文件，如今天是2014年02月18日期，那么 `{fileName}` = `20140218`;\r\n\r\n还记得 `php.ini` 中设置的 `seaslog.disting_type` 吗？\r\n\r\n默认的 `seaslog.disting_type = 0`，如果今天我使用了 `SeasLog` ，那么将产生最终的log文件：\r\n* LogFile = basePath / logger / 20140218.log\r\n\r\n如果 `seaslog.disting_type = 1`，则最终的log文件将是这样的三个文件\r\n* infoLogFile = basePath / logger / INFO.20140218.log\r\n\r\n* warnLogFile = basePath / logger / WARN.20140218.log\r\n\r\n* erroLogFile = basePath / logger / ERRO.20140218.log\r\n\r\n```php\r\nseaslog('this is a info');\r\nseaslog('this is a error 1', SEASLOG_TYPE_ERRO);\r\nseaslog('this is a error 2', SEASLOG_TYPE_ERRO);\r\nseaslog('this is a warning', SEASLOG_TYPE_WARN);\r\n\r\nseaslog('test error 3', SEASLOG_TYPE_ERRO, 'test/new/path');\r\n/*\r\nseaslog()函数同时也接受第3个参数为logger的设置项\r\n注意，当last_logger == 'default'时等同于:\r\nseaslog_set_logger('test/new/path');\r\nseaslog('test error 3', SEASLOG_TYPE_ERRO);\r\n如果已经在前文使用过seaslog_set_logger函数，第3个参数的log只在此处临时使用，不影响下文。\r\n*/\r\n```\r\n> log格式统一为： `{type} | {pid} | {timeStamp} |{dateTime} | {logInfo}`\r\n```sh\r\nERRO | 7670 | 1393171368.875 | 2014:02:24 00:02:48 | test error 3\r\nINFO | 7670 | 1393171372.344 | 2014:02:24 00:02:52 | this is a info \r\nERRO | 7670 | 1393171515.336 | 2014:02:24 00:05:15 | this is a error 1\r\nERRO | 7670 | 1393171609.881 | 2014:02:24 00:06:49 | this is a error 2\r\n```\r\n\r\n### SeasLog Analyzer的使用\r\n#### 快速统计某类型log的count值\r\n`SeasLog`在扩展中使用管道调用shell命令 `grep -wc`快速地取得count值，并返回值(array || int)给PHP。\r\n```php\r\n$countResult_1 = seaslog_analyzer_count();\r\n$countResult_2 = seaslog_analyzer_count(SEASLOG_TYPE_WARN);\r\n$countResult_3 = seaslog_analyzer_count(SEASLOG_TYPE_ERRO,date('Ymd',time()));\r\n\r\nvar_dump($countResult_1,$countResult_2,$countResult_3);\r\n/*\r\narray(3) {\r\n  'INFO' =>\r\n  int(0)\r\n  'WARN' =>\r\n  int(0)\r\n  'ERRO' =>\r\n  int(7)\r\n}\r\n\r\nint(7)\r\n\r\nint(1)\r\n\r\n*/\r\n```\r\n#### 获取某类型log列表\r\n`SeasLog`在扩展中使用管道调用shell命令 `grep -w`快速地取得列表，并返回array给PHP。\r\n```php\r\n$detailErrorArray_inAll   = seaslog_analyzer_detail(SEASLOG_TYPE_ERRO);\r\n$detailErrorArray_today   = seaslog_analyzer_detail(SEASLOG_TYPE_ERRO,date('Ymd',time()));\r\n\r\nvar_dump($detailErrorArray_inAll,$detailErrorArray_today);\r\n\r\n/*\r\nseaslog_analyzer_detail(SEASLOG_TYPE_ERRO) == seaslog_analyzer_detail(SEASLOG_TYPE_ERRO,'*');\r\n取当前模块下所有type为 SEASLOG_TYPE_ERRO 的信息列表:\r\narray(6) {\r\n [0] =>\r\n  string(66) \"ERRO | 8568 | 1393172042.717 | 2014:02:24 00:14:02 | test error 3 \"\r\n  [1] =>\r\n  string(66) \"ERRO | 8594 | 1393172044.104 | 2014:02:24 00:14:04 | test error 3 \"\r\n  [2] =>\r\n  string(66) \"ERRO | 8620 | 1393172044.862 | 2014:02:24 00:14:04 | test error 3 \"\r\n  [3] =>\r\n  string(66) \"ERRO | 8646 | 1393172045.989 | 2014:02:24 00:14:05 | test error 3 \"\r\n  [4] =>\r\n  string(66) \"ERRO | 8672 | 1393172047.882 | 2014:02:24 00:14:07 | test error 3 \"\r\n  [5] =>\r\n  string(66) \"ERRO | 8698 | 1393172048.736 | 2014:02:24 00:14:08 | test error 3 \"\r\n}\r\n\r\nseaslog_analyzer_detail(SEASLOG_TYPE_ERRO,date('Ymd',time()));\r\n只取得当前模块下，当前一天内,type为 SEASLOG_TYPE_ERRO 的信息列表:\r\narray(2) {\r\n  [0] =>\r\n  string(66) \"ERRO | 8568 | 1393172042.717 | 2014:02:24 00:14:02 | test error 3 \"\r\n  [1] =>\r\n  string(66) \"ERRO | 8594 | 1393172044.104 | 2014:02:24 00:14:04 | test error 3 \"\r\n}\r\n\r\n同理，取当月 \r\n$detailErrorArray_mouth = seaslog_analyzer_detail(SEASLOG_TYPE_ERRO,date('Ym',time()));\r\n\r\n*/\r\n```\r\n\r\n### 使用SeasLog进行健康预警\r\n#### 预警的配置\r\n```conf\r\n[base]\r\nwait_analyz_log_path = /log/base_test\r\n\r\n[fork]\r\n;是否开启多线程 1开启 0关闭\r\nfork_open = 1\r\n\r\n;线程个数\r\nfork_count = 3\r\n\r\n[warning]\r\nemail[smtp_host] = smtp.163.com\r\nemail[smtp_port] = 25\r\nemail[subject_pre] = 预警邮件 -\r\nemail[smtp_user] = seaslogdemo@163.com\r\nemail[smtp_pwd] = seaslog#demo\r\nemail[mail_from] = seaslogdemo@163.com\r\nemail[mail_to] = gaochitao@weiboyi.com\r\nemail[mail_cc] = ciogao@gmail.com\r\nemail[mail_bcc] =\r\n\r\n[analyz]\r\n; enum\r\n;info => SEASLOG_TYPE_INFO\r\n;warn => SEASLOG_TYPE_WARN\r\n;erro => SEASLOG_TYPE_ERRO\r\n\r\ntest1[module] = test/bb\r\ntest1[type] = SEASLOG_TYPE_ERRO\r\ntest1[bar] = 1\r\ntest1[mail_to] = gaochitao@weiboyi.com\r\n\r\ntest2[module] = 222\r\ntest2[type] = SEASLOG_TYPE_INFO\r\n\r\ntest3[module] = 333\r\ntest3[type] = SEASLOG_TYPE_WARN\r\n\r\ntest4[module] = 444\r\ntest4[type] = SEASLOG_TYPE_WARN\r\n\r\ntest5[module] = 555\r\ntest5[type] = SEASLOG_TYPE_WARN\r\n\r\n```\r\n#### crontab配置\r\n```conf\r\n;每天凌晨3点执行\r\n0 3 * * * /path/to/php /path/to/SeasLog/Analyzer/SeasLogAnalyzer.php\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}